# SimpleCalculator

### Простой (или не очень) CLI калькулятор на Python с поддержкой переменных и пользовательских функций.

Лабораторная работа №1 (вариант М4).

## Функционал

#### Базовые операции:

- `+`, `-`, `*`, `/` — стандартные арифметические операции
- `//` — целочисленное деление (по ТЗ только для целых чисел)
- `%` — остаток от деления (по ТЗ только для целых чисел)
- `**` — возведение в степень (правоассоциативная операция)

#### Числа:

- Целые: `42`, `-17`, `1_000_000`
- Вещественные: `3.14`, `-0.5`, `.25` (как в Python)
- Поддержка разделителя `_` для читаемости больших чисел

#### Скобки:

- Любая вложенность: `(((1+2)*3)-4)/5`
- Автоматическое удаление лишних внешних скобок
- Проверка баланса скобок с понятными сообщениями об ошибках

#### Переменные:

- Объявление переменной: `x = 10 + 5 * 2`
- Использование в выражениях: `y = x * 3 + 7`
- Ограничения: имена должна начинаться с буквы, могут содержать буквы, цифры и `_`

#### Встроенные функции:

- `min(1, 2, 3, 4)` — минимум (любое количество аргументов)
- `max(5, 10, 15)` — максимум (любое количество аргументов)
- `sqrt(16)` — квадратный корень
- `abs(-5)` — модуль числа
- `pow(2, 3)` — возведение в степень (альтернатива `**`)

#### Пользовательские функции:

- Объявление функции: `f = lambda(x,y): x**2 + y**2`
- Использование: `f(3, 4)` = `25.0`
- Любое количество аргументов: `sum = lambda(a,b,c): a+b+c`
- Внутри можно использовать другие переменные и функции

## Как работает

Калькулятор использует рекурсивный спуск для разбора выражений. Сначала выражение очищается от пробелов,
далее происходит приведение к нужным операторам (`//` -> `#`, `**` -> `^` для упрощенной обработки). Далее:

1. **Поиск чисел** - если выражение - число, то возвращается как есть (базовый случай рекурсии).
2. **Обработка унарных операторов** - выражения вида `-5` преобразуются в `0-5` опять же для упрощения обработки.
3. **Разделение по операторам** - выражение разбивается на части по операторам с учётом приоритетов и скобок.
4. **Рекурсивное вычисление** - рекурсивно вычисляется значение каждой части.
5. **Применение операторов** - применяются операторы текущего уровня разбиения.
6. **Попытка обработать как переменную** — если разбить по операторам не получилось, то пытаемся обработать как переменную иил вызов функции.

### Некоторые детали

#### Приоритет операторов:
1. `^` (степень) — правоассоциативный
2. `*`, `/`, `#`, `%` — левоассоциативные
3. `+`, `-` — левоассоциативные

#### Обработка ошибок:

- Все предвиденные ошибки оборачиваются в `UserFriendlyException` с понятными сообщениями
- Проверка деления на ноль
- Проверка целочисленности для `//` и `%`
- Проверка переполнения
- Подробный вывод по синтаксическим ошибкам

**Все результаты округляются до 2 знаков после запятой.**

## Примеры работы

### Базовые вычисления

```
>>> 2 + 3 * 4
14.0
>>> (2 + 3) * 4
20.0
>>> 2**3**2  # 2^(3^2) = 2^9
512.0
```

### Переменные

```
>>> a = 10
OK
>>> b = 20
OK
>>> a + b
30.0
>>> c = a * b + 5
OK
>>> c
205.0
```

### Функции

```
>>> min(5, 3, 8, 1, 9)
1.0
>>> sqrt(9) + abs(-5)
8.0
>>> pow(2, 8)
256.0
```

### Пользовательские функции

```
>>> a = 5
OK
>>> myfunc = lambda(x, y): x*x + y - a
OK
>>> myfunc(5, 10)
30.0
```

## Структура

- `expressions.py` - основная логика вычисления значения выражения
- `calculator.py` - обработка ввода, хранение глобального состояния
- `name_tables.py` - таблица имен для переменных и функций
- `operators.py` - операторы
- `functions.py` - базовый класс для функций и реализации встроенных функций
- `user_functions.py` - функционал для объявления пользовательских функций
- `common.py` — вспомогательные штуки, используемые в разных модулях


## Особенности реализации

### Без регулярных выражений

Весь парсинг реализован с нуля без регулярных выражений. Мне показалось, что так интереснее.

### Рекурсивный спуск

Выражения обрабатываются рекурсивно, что позволяет обрабатывать выражения почти любой сложности, при этом сохраняя довоьлно простой и читаемый код.<br>
Также это намного проще тестировать.

### Flyweight для операторов

Операторы создаются один раз и кэшируются для экономии памяти и упрощения сравнений.

### Расширяемость

Можно легко добавлять новые операторы (просто добавить в `_OP_MAP`), встроенные функции (`BUILTINS`) и встроенные переменные (`NametableManager`).


## Ограничения

1. **Рекурсия** — технически она работает, но из-за отсутствия ветвления всегда бесконечно зацикливается и дает ошибку.

2. **Всегда float** — все числа в результате будут вещественными и выводиться с дробной частью (даже если она 0).

3. **Имена переменных/функций** — только латиница, цифры и `_`. Начинается обязательно с буквы.

## Тесты

Имеются как юнит-тесты отдельных функций, так и 'сквозные' тесты.
Тестами покрыт практически весь основной функционал, проверены как различные успешные случаи, так и некорректные вводы.
Интересные (возможно) тесты:

- Очень длинное выражение (140 различных операций и очень много скобок)
- Всевозможные комбинации скобок
- Лишние скобки - (((1+2)))
- Композиция функций
- Порядок выполнения правоассоциативных операторов

## Результаты

- Код получился относительно чистым: удалось избежать рекурсивных зависимостей (выражения вызывают функции, а функции
  могут задаваться выражением);
  более-менее соблюдено разделение ответственности; не нарушен LSP (хотя CodeBasedFunction и UserDefinedFunction требуют
  разных данных).
- Обошелся без регулярных выражений.
- Практически все функции полностью задокументированы.
- Хорошее покрытие тестами разных видов (70+ кейсов). В pre-commit добавлено авто-выполнение тестов перед коммитом (19
  ms, приемлемо для такого проекта).
- Сработался со статическими анализаторами из pre-commit.
- Попробовал `uv`. Раньше использовал в основном `poetry`.
- Заставил себя написать нормальный README.

## Установка

Клонирование репозитория:

```shell
git clone https://github.com/TheMrKan/SimpleCalculator
cd SimpleCalculator
```

Запуск:

```shell
python3 -m src.main
```

### Зависимости

Тестировался на **Python 3.12**, и **3.10**.
Для использования установка каких-либо пакетов не требуется.

Для разработки потребуется установить `uv`:

```shell
python3 -m pip install uv
```

Установить пакеты (`pre-commit`):

```shell
uv sync
```

Включить pre-commit:

```shell
pre-commit install
```
